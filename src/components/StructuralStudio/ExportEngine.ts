/**
 * GPCS CodeStudio - Export Engine
 * 
 * Professional export with multiple formats
 * PDF/AI with spot colors and overprint
 * DXF, CFF2, SVG
 * Production pack with report and preview
 */

import type { DieLineInfo, DieSegment, DiePath, DieLineType } from '../../prepress/dieline/DieLineTypes'
import { validateDieLine, generateValidationReport, VALIDATION_PROFILES } from './ValidationEngine'

// Line type to color mapping for exports
const LINE_TYPE_COLORS: Record<DieLineType, { r: number; g: number; b: number; name: string }> = {
  'CUT': { r: 255, g: 0, b: 0, name: 'Die Cut' },
  'CREASE': { r: 0, g: 255, b: 0, name: 'Crease' },
  'PERFORATION': { r: 255, g: 255, b: 0, name: 'Perforation' },
  'PARTIAL_CUT': { r: 255, g: 128, b: 0, name: 'Partial Cut' },
  'REVERSE_CREASE': { r: 0, g: 200, b: 100, name: 'Reverse Crease' },
  'SCORE': { r: 0, g: 200, b: 200, name: 'Score' },
  'ZIPPER': { r: 128, g: 0, b: 255, name: 'Zipper' },
  'BLEED': { r: 0, g: 0, b: 255, name: 'Bleed' },
  'ANNOTATION': { r: 128, g: 128, b: 128, name: 'Annotation' },
  'GLUE': { r: 200, g: 0, b: 200, name: 'Glue Area' },
  'VARNISH_FREE': { r: 255, g: 0, b: 128, name: 'Varnish Free' },
  'STRIPPING': { r: 100, g: 100, b: 100, name: 'Stripping' },
  'REGISTER': { r: 0, g: 255, b: 255, name: 'Register Mark' },
  'UNKNOWN': { r: 150, g: 150, b: 150, name: 'Unknown' }
}

// Line type dash patterns
const LINE_TYPE_DASHES: Record<DieLineType, number[]> = {
  'CUT': [],
  'CREASE': [4, 2],
  'PERFORATION': [1, 1],
  'PARTIAL_CUT': [6, 2],
  'REVERSE_CREASE': [4, 2],
  'SCORE': [],
  'ZIPPER': [],
  'BLEED': [],
  'ANNOTATION': [2, 2],
  'GLUE': [8, 2, 2, 2],
  'VARNISH_FREE': [],
  'STRIPPING': [4, 4],
  'REGISTER': [],
  'UNKNOWN': [2, 2]
}

export interface ExportOptions {
  format: 'SVG' | 'PDF' | 'DXF' | 'CFF2' | 'AI'
  includeBleed?: boolean
  includeSafeArea?: boolean
  includeAnnotations?: boolean
  spotColors?: boolean
  overprint?: boolean
  scale?: number
  units?: 'MM' | 'INCH' | 'PT'
}

export interface ProductionPackOptions {
  includeReport?: boolean
  includePreview?: boolean
  includeSVG?: boolean
  includePDF?: boolean
  includeDXF?: boolean
  includeCFF2?: boolean
  validationProfile?: string
}

// Export to SVG
export function exportToSVG(dieLine: DieLineInfo, options: ExportOptions = { format: 'SVG' }): string {
  const scale = options.scale || 1
  const padding = 10
  const width = (dieLine.width + padding * 2) * scale
  const height = (dieLine.height + padding * 2) * scale
  
  let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     width="${width}mm" 
     height="${height}mm" 
     viewBox="0 0 ${width} ${height}">
  <title>${dieLine.name}</title>
  <desc>Generated by GPCS CodeStudio</desc>
  
  <!-- Metadata -->
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:dc="http://purl.org/dc/elements/1.1/">
      <rdf:Description>
        <dc:title>${dieLine.name}</dc:title>
        <dc:creator>GPCS CodeStudio</dc:creator>
        <dc:date>${new Date().toISOString()}</dc:date>
      </rdf:Description>
    </rdf:RDF>
  </metadata>
  
  <g transform="translate(${padding * scale}, ${padding * scale})">
`

  // Group paths by line type
  const pathsByType = new Map<DieLineType, DiePath[]>()
  dieLine.paths.forEach(path => {
    const type = path.lineType || path.segments[0]?.lineType || 'CUT'
    if (!pathsByType.has(type)) pathsByType.set(type, [])
    pathsByType.get(type)!.push(path)
  })

  // Render each layer
  pathsByType.forEach((paths, lineType) => {
    const color = LINE_TYPE_COLORS[lineType]
    const dash = LINE_TYPE_DASHES[lineType]
    const dashStr = dash.length > 0 ? `stroke-dasharray="${dash.join(' ')}"` : ''
    
    svg += `    <!-- Layer: ${color.name} -->\n`
    svg += `    <g id="layer-${lineType}" class="dieline-layer" data-type="${lineType}">\n`
    
    paths.forEach(path => {
      const d = pathToSVGPath(path, scale)
      svg += `      <path d="${d}" 
             fill="none" 
             stroke="rgb(${color.r},${color.g},${color.b})" 
             stroke-width="0.5"
             ${dashStr}
             data-id="${path.id}"/>\n`
    })
    
    svg += `    </g>\n`
  })

  svg += `  </g>
</svg>`

  return svg
}

// Convert path to SVG path data
function pathToSVGPath(path: DiePath, scale: number): string {
  if (path.segments.length === 0) return ''
  
  let d = `M ${path.segments[0].start.x * scale} ${path.segments[0].start.y * scale}`
  
  path.segments.forEach(seg => {
    if (seg.type === 'LINE') {
      d += ` L ${seg.end.x * scale} ${seg.end.y * scale}`
    } else if (seg.type === 'ARC' && seg.center && seg.radius) {
      const rx = seg.radius * scale
      const ry = seg.radius * scale
      const largeArc = 0
      const sweep = seg.clockwise ? 0 : 1
      d += ` A ${rx} ${ry} 0 ${largeArc} ${sweep} ${seg.end.x * scale} ${seg.end.y * scale}`
    } else if (seg.type === 'BEZIER' && seg.controlPoints) {
      const cp = seg.controlPoints
      if (cp.length === 2) {
        d += ` C ${cp[0].x * scale} ${cp[0].y * scale} ${cp[1].x * scale} ${cp[1].y * scale} ${seg.end.x * scale} ${seg.end.y * scale}`
      }
    }
  })
  
  if (path.isClosed) d += ' Z'
  
  return d
}

// Export to DXF
export function exportToDXF(dieLine: DieLineInfo, options: ExportOptions = { format: 'DXF' }): string {
  const scale = options.units === 'INCH' ? 0.03937 : 1
  
  let dxf = `0
SECTION
2
HEADER
9
$ACADVER
1
AC1015
9
$INSUNITS
70
${options.units === 'INCH' ? 1 : 4}
0
ENDSEC
0
SECTION
2
TABLES
0
TABLE
2
LAYER
`

  // Define layers
  const lineTypes = new Set<DieLineType>()
  dieLine.paths.forEach(path => {
    path.segments.forEach(seg => lineTypes.add(seg.lineType))
  })

  lineTypes.forEach(lt => {
    const color = LINE_TYPE_COLORS[lt]
    const aciColor = rgbToACI(color.r, color.g, color.b)
    dxf += `0
LAYER
2
${lt}
70
0
62
${aciColor}
6
CONTINUOUS
`
  })

  dxf += `0
ENDTAB
0
ENDSEC
0
SECTION
2
ENTITIES
`

  // Export entities
  dieLine.paths.forEach(path => {
    path.segments.forEach(seg => {
      if (seg.type === 'LINE') {
        dxf += `0
LINE
8
${seg.lineType}
10
${seg.start.x * scale}
20
${seg.start.y * scale}
30
0.0
11
${seg.end.x * scale}
21
${seg.end.y * scale}
31
0.0
`
      } else if (seg.type === 'ARC' && seg.center && seg.radius) {
        const startAngle = Math.atan2(seg.start.y - seg.center.y, seg.start.x - seg.center.x) * 180 / Math.PI
        const endAngle = Math.atan2(seg.end.y - seg.center.y, seg.end.x - seg.center.x) * 180 / Math.PI
        
        dxf += `0
ARC
8
${seg.lineType}
10
${seg.center.x * scale}
20
${seg.center.y * scale}
30
0.0
40
${seg.radius * scale}
50
${startAngle}
51
${endAngle}
`
      }
    })
  })

  dxf += `0
ENDSEC
0
EOF
`

  return dxf
}

// Export to CFF2
export function exportToCFF2(dieLine: DieLineInfo, options: ExportOptions = { format: 'CFF2' }): string {
  const scale = options.units === 'INCH' ? 0.03937 : 1
  
  let cff = `UNITS,${options.units === 'INCH' ? 'INCH' : 'MM'}
DESIGN,${dieLine.name}
DATE,${new Date().toISOString().split('T')[0]}
CREATOR,GPCS CodeStudio
`

  // CFF2 line type codes
  const CFF2_TYPE_CODES: Record<DieLineType, number> = {
    'CUT': 1,
    'CREASE': 2,
    'PERFORATION': 3,
    'PARTIAL_CUT': 4,
    'REVERSE_CREASE': 5,
    'SCORE': 6,
    'ZIPPER': 7,
    'BLEED': 8,
    'ANNOTATION': 9,
    'GLUE': 10,
    'VARNISH_FREE': 11,
    'STRIPPING': 12,
    'REGISTER': 13,
    'UNKNOWN': 0
  }

  dieLine.paths.forEach(path => {
    path.segments.forEach(seg => {
      const typeCode = CFF2_TYPE_CODES[seg.lineType] || 0
      
      if (seg.type === 'LINE') {
        cff += `L,${(seg.start.x * scale).toFixed(4)},${(seg.start.y * scale).toFixed(4)},${(seg.end.x * scale).toFixed(4)},${(seg.end.y * scale).toFixed(4)},${typeCode}\n`
      } else if (seg.type === 'ARC' && seg.center && seg.radius) {
        const dir = seg.clockwise ? 0 : 1
        cff += `A,${(seg.start.x * scale).toFixed(4)},${(seg.start.y * scale).toFixed(4)},${(seg.end.x * scale).toFixed(4)},${(seg.end.y * scale).toFixed(4)},${(seg.center.x * scale).toFixed(4)},${(seg.center.y * scale).toFixed(4)},${dir},${typeCode}\n`
      }
    })
  })

  cff += `END\n`
  
  return cff
}

// Generate production pack (ZIP with all files)
export async function generateProductionPack(
  dieLine: DieLineInfo, 
  options: ProductionPackOptions = {}
): Promise<{ filename: string; content: Blob }[]> {
  const files: { filename: string; content: Blob }[] = []
  const baseName = dieLine.name.replace(/\.[^.]+$/, '').replace(/[^a-zA-Z0-9_-]/g, '_')
  
  // SVG export
  if (options.includeSVG !== false) {
    const svg = exportToSVG(dieLine)
    files.push({
      filename: `${baseName}_dieline.svg`,
      content: new Blob([svg], { type: 'image/svg+xml' })
    })
  }
  
  // DXF export
  if (options.includeDXF !== false) {
    const dxf = exportToDXF(dieLine)
    files.push({
      filename: `${baseName}_dieline.dxf`,
      content: new Blob([dxf], { type: 'application/dxf' })
    })
  }
  
  // CFF2 export
  if (options.includeCFF2 !== false) {
    const cff = exportToCFF2(dieLine)
    files.push({
      filename: `${baseName}_dieline.cff`,
      content: new Blob([cff], { type: 'text/plain' })
    })
  }
  
  // Validation report
  if (options.includeReport !== false) {
    const profile = VALIDATION_PROFILES.find(p => p.id === options.validationProfile) || VALIDATION_PROFILES[0]
    const results = validateDieLine(dieLine, profile)
    const report = generateValidationReport(dieLine, results)
    files.push({
      filename: `${baseName}_report.txt`,
      content: new Blob([report], { type: 'text/plain' })
    })
  }
  
  // Info JSON
  const info = {
    name: dieLine.name,
    format: dieLine.format,
    width: dieLine.width,
    height: dieLine.height,
    unit: dieLine.unit,
    paths: dieLine.paths.length,
    segments: dieLine.paths.reduce((a, p) => a + p.segments.length, 0),
    created: dieLine.created,
    modified: dieLine.modified,
    exportedAt: new Date().toISOString(),
    exportedBy: 'GPCS CodeStudio'
  }
  files.push({
    filename: `${baseName}_info.json`,
    content: new Blob([JSON.stringify(info, null, 2)], { type: 'application/json' })
  })
  
  return files
}

// Helper: RGB to AutoCAD Color Index
function rgbToACI(r: number, g: number, b: number): number {
  // Simplified mapping to ACI colors
  if (r > 200 && g < 50 && b < 50) return 1 // Red
  if (r < 50 && g > 200 && b < 50) return 3 // Green
  if (r < 50 && g < 50 && b > 200) return 5 // Blue
  if (r > 200 && g > 200 && b < 50) return 2 // Yellow
  if (r > 200 && g < 50 && b > 200) return 6 // Magenta
  if (r < 50 && g > 200 && b > 200) return 4 // Cyan
  if (r > 200 && g > 100 && b < 50) return 30 // Orange
  return 7 // White/default
}

// Export engine object
export const ExportEngine = {
  exportToSVG,
  exportToDXF,
  exportToCFF2,
  generateProductionPack,
  LINE_TYPE_COLORS,
  LINE_TYPE_DASHES
}
